<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>estado novo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.js"></script>
  <style>body{margin:0;background:#222;display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial;color:#fff;} #info{position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.7);padding:10px;font-size:12px;}</style>
</head>
<body>
<div id="info">WASD/Setas: Mover | Espaço: Pular<br/>Câmera: Clique + Arraste</div>
<script>
// world.js - sistema de colisão melhorado

function world_new() {
  const RUN_FRAMES = 5;
  const USE_FRAMES = 3;
  const FRAME_INTERVAL = 120;
  const GRAVITY = 0.6;
  const GROUND_Y = -40;
  const COLLISION_MARGIN = 2;
  const STEP_HEIGHT = 20;

  const world = {
    cubes: [],
    creatures: [],
    models: { player: {} },
    modelBounds: { player: {} },
    lastAnimTime: 0,

    // ---------------------------
    // API
    // ---------------------------
    new_cube(pos, size) {
      this.cubes.push({ pos, size });
    },

    new_creature(opts) {
      const ent = {
        position: opts.position.copy(),
        size: opts.size || createVector(40,80,40),
        state: opts.state || "idle",
        frame: 0,
        rotation: 0,
        vel: createVector(0,0,0),
        npc: opts.npc || false,
        dirVec: opts.dirVec || createVector(0,0,0),
        speed: opts.speed || 0,
        spawnPos: opts.spawnPos || null,
        targetPos: opts.targetPos || null,
        traveling: opts.traveling || false,
        arrivedAt: 0,
        respawnDelay: opts.respawnDelay || 1200,
        startDelay: opts.startDelay || 0,
        modelScale: opts.modelScale || 1,
        onGround: true,
        _lastAnimTime: millis()
      };
      this.creatures.push(ent);
      return ent;
    },

    render() {
      background(28);
      orbitControl();

      ambientLight(100);
      directionalLight(255, 255, 255, 0.5, 1, -0.5);

      // chão
      push();
      rotateX(HALF_PI);
      noStroke();
      fill(80, 120, 80);
      plane(6000,6000);
      pop();

      // cubos
      for (let c of this.cubes){
        push();
        translate(c.pos.x, c.pos.y, c.pos.z);
        fill(150, 100, 50);
        noStroke();
        box(c.size.x, c.size.y, c.size.z);
        pop();
      }

      // update + render creatures
      for (let ent of this.creatures){
        this.updateCreature(ent);
        const model = world.safeModelAt(ent.state, ent.frame);
        this.drawModel(ent.position, model, ent.rotation, ent.modelScale);
      }
    },

    // ---------------------------
    // Internals
    // ---------------------------
    safeModelAt(state, frame) {
      const states = this.models.player;
      if (!states[state]) return null;
      if (!states[state][frame]) return null;
      return states[state][frame];
    },

    updateCreature(ent) {
      // gravidade
      ent.vel.y += GRAVITY * (deltaTime/16.666);
      ent.position.y += ent.vel.y * (deltaTime/16.666);

      // usa movimento externo
      let moveVec = (ent._inputMoveVec) ? ent._inputMoveVec.copy() : createVector(0,0,0);

      // NPC movimentação
      if (ent.npc) {
        if (ent.traveling) {
          ent.state = 'run';
          const mv = p5.Vector.mult(ent.dirVec, ent.speed * (deltaTime/16.666));
          ent.position.add(mv);
          moveVec = ent.dirVec.copy();

          if (ent.targetPos && p5.Vector.sub(ent.targetPos, ent.position).mag() < 6) {
            ent.traveling = false;
            ent.arrivedAt = millis();
            ent.state = 'idle';
            ent.frame = 0;
          }
        } else {
          ent.state = 'idle';
          ent.frame = 0;

          if (ent.arrivedAt && millis() - ent.arrivedAt > ent.respawnDelay) {
            const base = (ent.spawnPos) ? ent.spawnPos.copy() : ent.position.copy();
            const newTarget = createVector(base.x + random(-200,200), base.y, base.z + random(-200,200));
            ent.targetPos = newTarget;
            ent.dirVec = p5.Vector.sub(ent.targetPos, ent.position).normalize();
            ent.traveling = true;
            ent.arrivedAt = 0;
            ent.state = 'run';
          }
        }
      } else {
        // jogador: aplica movimento com colisão
        if (moveVec && moveVec.mag() > 0.001) {
          ent.state = 'run';
          const scaled = p5.Vector.mult(moveVec, (deltaTime/16.666));
          this.resolveMovementCollision(ent, scaled);
        } else {
          ent.state = 'idle';
        }
      }

      // resolve colisões verticais (gravidade + chão)
      this.resolveVerticalCollision(ent);

      // atualiza rotação
      if ((ent.npc && moveVec.mag() > 0.001) || (ent._inputMoveVec && ent._inputMoveVec.mag() > 0.001)) {
        const faceVec = (ent.npc) ? moveVec.copy() : ent._inputMoveVec.copy();
        if (faceVec.mag() > 0.001) {
          ent.rotation = atan2(faceVec.x, faceVec.z);
        }
      }

      // animação
      if (!ent._lastAnimTime) ent._lastAnimTime = 0;
      if (millis() - ent._lastAnimTime > FRAME_INTERVAL) {
        ent._lastAnimTime = millis();
        if (ent.state === "run"){
          ent.frame = (ent.frame + 1) % RUN_FRAMES;
        } else {
          ent.frame = 0;
        }
      }

      if (ent._inputMoveVec) delete ent._inputMoveVec;
    },

    resolveMovementCollision(ent, movement) {
      // Tenta mover nos 3 eixos separadamente para deslizamento
      
      // X
      const nextX = p5.Vector.add(ent.position, createVector(movement.x, 0, 0));
      if (!this.collides3D(nextX, ent.size)) {
        ent.position = nextX;
      }

      // Z
      const nextZ = p5.Vector.add(ent.position, createVector(0, 0, movement.z));
      if (!this.collides3D(nextZ, ent.size)) {
        ent.position = nextZ;
      }
    },

    getAABB(pos, size) {
      const half = { x: size.x/2, y: size.y/2, z: size.z/2 };
      return {
        minX: pos.x - half.x,
        maxX: pos.x + half.x,
        minY: pos.y - half.y,
        maxY: pos.y + half.y,
        minZ: pos.z - half.z,
        maxZ: pos.z + half.z
      };
    },

    checkAABBCollision(aabb1, aabb2) {
      return !(aabb1.maxX < aabb2.minX + COLLISION_MARGIN ||
               aabb1.minX > aabb2.maxX - COLLISION_MARGIN ||
               aabb1.maxY < aabb2.minY + COLLISION_MARGIN ||
               aabb1.minY > aabb2.maxY - COLLISION_MARGIN ||
               aabb1.maxZ < aabb2.minZ + COLLISION_MARGIN ||
               aabb1.minZ > aabb2.maxZ - COLLISION_MARGIN);
    },

    collides3D(pos, size) {
      const aabb = this.getAABB(pos, size);
      for (let c of this.cubes) {
        const cubeAABB = this.getAABB(c.pos, c.size);
        if (this.checkAABBCollision(aabb, cubeAABB)) {
          return true;
        }
      }
      return false;
    },

    drawModel(pos, modelModel, rotation, modelScale) {
      push();
      translate(pos.x, pos.y, pos.z);
      rotateY(rotation);
      
      const normalizedScale = this.getNormalizedScale(modelModel) * modelScale;
      scale(normalizedScale * 100);
      scale(1, -1, 1);
      translate(0, 60, 0);
      noStroke();
      
      if (modelModel) {
        model(modelModel);
      } else {
        fill(100, 150, 255);
        box(40, 80, 20);
      }
      
      pop();
    },

    getNormalizedScale(model) {
      if (!model) return 1;
      
      const modelKey = this.getModelKey(model);
      if (this.modelBounds[modelKey]) {
        return this.modelBounds[modelKey];
      }
      
      let minY = Infinity, maxY = -Infinity;
      
      if (model.vertices) {
        for (let v of model.vertices) {
          if (v.y < minY) minY = v.y;
          if (v.y > maxY) maxY = v.y;
        }
        
        const height = maxY - minY;
        if (height > 0) {
          const normalizedScale = 2 / height;
          this.modelBounds[modelKey] = normalizedScale;
          return normalizedScale;
        }
      }
      
      this.modelBounds[modelKey] = 1;
      return 1;
    },

    getModelKey(model) {
      if (model && model.vertices) {
        return `model_${model.vertices.length}`;
      }
      return 'unknown';
    },

    cameraRelativeMovement() {
      const cam = _renderer._curCamera;
      let forward = createVector(cam.centerX - cam.eyeX, 0, cam.centerZ - cam.eyeZ);
      if (forward.mag() === 0) forward = createVector(0,0,1);
      forward.normalize();
      let right = createVector(forward.z, 0, -forward.x);

      const speed = 3;
      let mv = createVector(0,0,0);

      if (keyIsDown(87) || keyIsDown(UP_ARROW)) mv.add(p5.Vector.mult(forward, speed));
      if (keyIsDown(83) || keyIsDown(DOWN_ARROW)) mv.sub(p5.Vector.mult(forward, speed));
      if (keyIsDown(68) || keyIsDown(RIGHT_ARROW)) mv.sub(p5.Vector.mult(right, speed));
      if (keyIsDown(65) || keyIsDown(LEFT_ARROW)) mv.add(p5.Vector.mult(right, speed));

      return mv;
    },

    jump(ent) {
      if (ent.onGround) {
        ent.vel.y = -15;
        ent.onGround = false;
      }
    },

    resolveVerticalCollision(ent) {
      let bestSurface = null;
      for (let c of this.cubes) {
        const halfC = { x: c.size.x/2, y: c.size.y/2, z: c.size.z/2 };
        const halfE = { x: ent.size.x/2, z: ent.size.z/2 };
        
        if (ent.position.x + halfE.x > c.pos.x - halfC.x &&
            ent.position.x - halfE.x < c.pos.x + halfC.x &&
            ent.position.z + halfE.z > c.pos.z - halfC.z &&
            ent.position.z - halfE.z < c.pos.z + halfC.z) {
          
          const surfaceY = c.pos.y - halfC.y - ent.size.y/2;
          if (surfaceY <= ent.position.y) {
            if (bestSurface === null || surfaceY > bestSurface) {
              bestSurface = surfaceY;
            }
          }
        }
      }

      if (bestSurface !== null) {
        ent.position.y = bestSurface;
        ent.vel.y = 0;
        ent.onGround = true;
        return;
      }

      if (ent.position.y >= GROUND_Y) {
        ent.position.y = GROUND_Y;
        ent.vel.y = 0;
        ent.onGround = true;
      } else {
        ent.onGround = false;
      }
    }
  };

  return world;
}


let world;

const RUN_FRAMES = 5;
const USE_FRAMES = 3;

function preload() {
  world = world_new();
  
  world.models.player.idle = [];
  world.models.player.idle[0] = safeLoadModel(`data/player/idle/0.obj`);

  world.models.player.run = [];
  for (let f=0; f<RUN_FRAMES; f++){
    world.models.player.run[f] = safeLoadModel(`data/player/run/${f}.obj`);
  }

  world.models.player.use = [];
  for (let f=0; f<USE_FRAMES; f++){
    world.models.player.use[f] = safeLoadModel(`data/player/use/${f}.obj`);
  }
}

function safeLoadModel(path) {
  let mdl = null;
  try {
    mdl = loadModel(path, true, 
      () => { console.log('Modelo carregado:', path); }, 
      () => { console.log('Erro ao carregar:', path); }
    );
  } catch(e) {
    console.log('Exceção ao carregar modelo:', path, e);
  }
  return mdl;
}

function setup() {
  createCanvas(800,600,WEBGL);

    // posicionamento inicial da câmera: eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ
  camera(100, -500, 900,   // posição da câmera (eye)
         0, 0, 0,     // centro/target da câmera (center) -> centerX = 100 aqui
         0, 1, 0);      // vetor "up"
  
  world.new_cube(createVector(400,-40,0), createVector(120,80,120));
  world.new_cube(createVector(-320,-40,160), createVector(100,120,100));
  world.new_cube(createVector(0,-40,480), createVector(60,60,60));

  world.new_creature({
    position: createVector(0,-40,0),
    state: "idle",
    npc: false,
    modelScale: 1
  });

  for (let i=0;i<3;i++){
    const spawn = createVector(random(-200,200), -40, random(-200,200));
    const target = createVector(random(-200,200), -40, random(-200,200));
    const dir = p5.Vector.sub(target, spawn).normalize();
    world.new_creature({
      position: spawn,
      npc: true,
      traveling: true,
      dirVec: dir,
      speed: 1.2,
      targetPos: target,
      modelScale: 1
    });
  }
}

function draw() {
    if (world.creatures.length > 0) {
        const player = world.creatures[0];
        const movement = world.cameraRelativeMovement();
        if (movement.mag() > 0.001) {
            player._inputMoveVec = movement.copy();
            player.state = "run";
        } else {
            player.state = "idle";
            player.frame = 0;
            if (player._inputMoveVec) delete player._inputMoveVec;
        }

        // Pulo
        if (keyIsDown(32)) {
            world.jump(player);
        }
    }

    world.render();
}
</script>
</body>
</html>